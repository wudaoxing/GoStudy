<!-- TOC -->

- [第1章 逃逸分析](#第1章-逃逸分析)
  - [1.1 逃逸分析是什么](#11-逃逸分析是什么)
  - [1.2 逃逸分析有什么用](#12-逃逸分析有什么用)
  - [1.3 逃逸分析是怎么完成的](#13-逃逸分析是怎么完成的)
  - [1.4 如何确定是否发生逃逸](#14-如何确定是否发生逃逸)
  - [1.5 Go与C/C++中的堆和栈是同一个概念吗](#15-go与cc中的堆和栈是同一个概念吗)
- [第2章 延迟语句](#第2章-延迟语句)
  - [2.1 延迟语句是什么](#21-延迟语句是什么)
  - [2.2 延迟语句的执行顺序是什么](#22-延迟语句的执行顺序是什么)
  - [2.3 如何拆解延迟语句](#23-如何拆解延迟语句)
  - [2.4 如何确定延迟语句的参数](#24-如何确定延迟语句的参数)
  - [2.5 闭包是什么](#25-闭包是什么)
  - [2.6 延迟语句如何配合恢复语句](#26-延迟语句如何配合恢复语句)
  - [2.7 defer链如何被遍历执行（<font color="red"> 着实没看懂</font>）](#27-defer链如何被遍历执行font-colorred-着实没看懂font)
  - [2.8 为什么无法从父goroutine恢复子goroutine的panic](#28-为什么无法从父goroutine恢复子goroutine的panic)

<!-- /TOC -->
# 第1章 逃逸分析
* 在C/C++中，
  * 可以通过调用malloc函数或使用new运算符从堆上分配到一块内存；
  * 该内存的使用、销毁的责任都在程序员；
  * 一不小心，就会发生内存泄漏（比如，程序员忘记销毁）。
* 在Go语言中，
  * 程序员基本上不需要担心内存泄露了；
  * Go也有内建函数new，但调用new函数得到的内存不一定在堆上，还可能在栈上；
  * 一个变量是在堆上分配，还是在栈上分配，是经编译器的逃逸分析之后得出的“结论”。
##  1.1 逃逸分析是什么
* 堆与栈
  * 栈内存分配非常快。栈分配内存只需要通过PUSH指令，并且会被自动释放。局部变量是在栈上分配的（即静态内存分配），函数一旦执行完毕，变量占据的内存空间会被销毁；
  * 堆适合不可预知大小的内存分配。代价是分配速度较慢，而且会形成内存碎片。堆分配内存首先需要去找到一个合适大小的内存块，之后要通过垃圾回收才能释放。堆上创建的变量（动态内存分配），在函数退出时不会被销毁。

* 编译器的逃逸分析：  
  它是编译器执行静态代码分析后，对内存管理进行的优化和简化。
* 逃逸分析：
  * 在编译原理中，分析指针动态范围的方法被称之为逃逸分析。
  * 通俗来讲，当一个对象的指针被多个方法或线程引用时，则称这个指针发生了逃逸。
  * 逃逸分析决定一个变量是分配在堆上还是分配在栈上。

##  1.2 逃逸分析有什么用
* C/C++中动态分配的内存需要手动释放
  * 好处：程序员可以完全掌控内存
  * 缺点：例如经常忘记释放内存，导致内存泄漏。为此，很多现代语言都包含了垃圾回收机制
* Go的垃圾回收  
  让堆和栈对程序员保持透明。让程序员可以专注于业务，把内存管理的复杂机制交给编译器。

* 逃逸分析把变量合理地分配到它该去的地方
  * 即使是用new函数申请到的内存，如果编译器发现这块内存在退出函数后就没有使用了，那就分配到栈上（栈上的内存分配比堆上快很多）
  * 即使表面上只是一个普通的变量，但是经编译器的逃逸分析后发现，在函数之外还有其他的地方在引用，那就分配到堆上
  * 通过逃逸分析，可以尽量把那些不需要分配到堆上的变量直接分配到栈上：  
    堆上的变量少了，会减轻堆内存分配的开销，同时也会减少垃圾回收（Garbage Collection，GC）的压力，提高程序的运行速度。
* 如果变量都分配到堆上   
  堆不像栈可以自动清理。就会引起Go频繁地进行垃圾回收，而垃圾回收会占用比较大的系统开销

##  1.3 逃逸分析是怎么完成的
* Go语言逃逸分析最基本的原则：  
  如果一个函数返回对一个变量的引用，那么这个变量就会发生逃逸。
* 编译器会分析代码的特征和代码的生命周期
  * Go中的变量只有在编译器可以证明在函数返回后不会再被引用的，才分配到栈上，其他情况下都是分配到堆上。
  * Go语言中没有一个关键字或者函数可以直接让变量被分配到堆上
  * 对一个变量取址，可能会被分配到堆上。
    * 编译器进行逃逸分析后，考虑到在函数返回后，此变量不会被引用，那么还是会被分配到栈上。

* 编译器会根据变量是否被外部引用来决定是否逃逸；
  * 如果变量在函数外部没有引用，则优先放到栈上。
    * 放到堆上的情形：定义了一个很大的数组，需要申请的内存过大，超出了栈的存储能力
  * 如果变量在函数外部存在引用，则优先放到堆上。

##  1.4 如何确定是否发生逃逸
* Go提供了相关的命令，可以查看变量是否发生逃逸
  ```go
  go build -gcflags '-m -l' main.go
  其中：
  -gcflags参数：用于启动编译器支持的额外标志。例如，
  -m用于输出编译器的优化细节（包括使用逃逸分析这种优化），
  -N可以关闭编译器优化，
  -l用于禁用函数的内联优化，防止逃逸被编译器通过内联彻底的抹除
  ```
* 有些函数的参数为interface类型，编译期间很难确定其参数的具体类型，也会发生逃逸
* 使用反汇编命令也可以看出变量是否发生逃逸。
  ```go
  go tool compile -S main.go
  输出中如果有newobject函数（用于在堆上分配一块内存），说明有东西被存放在堆上，也就是发生了逃逸。
  ```

##  1.5 Go与C/C++中的堆和栈是同一个概念吗
* C/C++中提及的“程序堆栈”本质上其实是操作系统层级的概念，通过C/C++语言的编译器和所在的系统环境来共同决定。
  * 在程序启动时，操作系统会自动维护一个所启动程序消耗内存的地址空间，并自动将这个空间从逻辑上划分为堆内存空间和栈内存空间。这时，
    * “栈”的概念是指程序运行时自动获得的一小块内存，而后续的函数调用所消耗的栈大小，会在编译期间由编译器决定，用于保存局部变量或者保存函数调用栈。
      * 如果在C/C++中声明一个局部变量，则会执行逻辑上的压栈操作，在栈中记录局部变量。
      * 当局部变量离开作用域之后，所谓的自动释放本质上是该位置的内存在下一次函数调用压栈的过程中，可以被无条件的覆盖
    * 对于堆而言，每当程序通过系统调用向操作系统申请内存时，会将所需的空间从维护的堆内存空间中分配出去，而在归还时则会将归还的内存合并到所维护的地址空间中。
* Go程序也是运行在操作系统上的程序，同样拥有前面提及的堆和栈的概念。区别在于，
  * 传统意义上的“栈”被Go语言的运行时全部消耗了，用于维护运行时各个组件之间的协调。例如，
    * 调度器、垃圾回收、系统调用等
  * 对于用户态的Go代码而言，它们所消耗的“堆和栈”，其实只是Go运行时通过管理向操作系统申请的堆内存，构造的逻辑上的“堆和栈”，它们的本质都是从操作系统申请而来的堆内存。
    * 由于用户态Go程序的“栈空间”是由运行时管理堆内存得来，相较于只有1MB的C/C++中的“栈”而言，Go程序拥有“几乎”无限的栈内存（1GB）。
  * 对于用户态Go代码消耗的栈，Go语言运行时会为了防止内存碎片化，会在适当的时候对整个栈进行深拷贝，将其整个复制到另一块内存区域（这个过程对用户态的代码是不可见的），这也是相较于传统意义上栈是一块固定分配好的内存所出现的另一处差异
    * 由于这个特点，指针的算术运算不再能奏效，因为在没有特殊说明的情况下，无法确定运算前后指针所指向的地址的内容是否已经被Go运行时移动。

# 第2章 延迟语句
* 延迟语句（defer）
  * Go语言里的一个关键字
  * 能把资源的释放语句与申请语句放到距离相近的位置，从而减少了资源泄露的情况发生。

## 2.1 延迟语句是什么
* defer
  * 是Go语言提供的一种用于注册延迟调用的机制
  * 让函数或语句可以在当前函数执行完毕后（包括通过return正常结束或者panic导致的异常结束）执行。
  
* defer使用场景
  * 在需要释放资源的场景非常有用，可以很方便地在函数结束前做一些清理操作。
    * 在打开资源语句的下一行，直接使用defer就可以在函数返回前释放资源
  * 通常用于一些成对操作的场景：打开连接/关闭连接、加锁/释放锁、打开文件/关闭文件等
  * defer会有短暂延迟，对时间要求特别高的程序，可以避免使用它。Go 1.14对defer做了很大幅度的优化，效率提升了不少。

## 2.2 延迟语句的执行顺序是什么
* defer语句并不会马上执行，而是会进入一个栈，函数return前，会按先进后出的顺序执行。
  * 最先定义的defer语句最后执行
  * 原因：后面定义的函数可能会依赖前面的资源，自然要先执行；否则，如果前面先执行了，后面函数的依赖就没有了，可能会出错。
* 在defer函数定义时，对外部变量的引用有两种方式
  * 函数参数：在defer定义时就把值传递给defer，并被cache起来
  * 闭包引用：在defer函数真正调用时根据整个上下文确定参数当前的值
* defer后面的函数在执行的时候，函数调用的参数会被保存起来，也就是复制了一份。（先求值，再延迟调用：defer函数定义的时候，参数就已经复制进去了）
  * 真正执行的时候，实际上用到的是这个复制的变量
    * 如果此变量是一个“值”，那么就和定义的时候是一致的
    * 如果此变量是一个“引用”，那就可能和定义的时候不一致
* return之后的defer函数不能被注册
* 调用close()函数，需要先判断调用主体是否为空，否则可能会解引用了一个空指针，进而panic。

## 2.3 如何拆解延迟语句
```go
return xxx
上面这条语句经过编译之后，实际上生成了三条指令：
1.返回值 = xxx
2.调用defer函数
3.空的return
第1和第3步是return语句生成的指令，也就是说return并不是一条原子操作；
第2步是defer定义的语句，这里可能会操作返回值，从而影响最终结果。
```
## 2.4 如何确定延迟语句的参数
* defer语句表达式的值在定义时就已经确定了。
* 需要注意闭包，容易犯错

## 2.5 闭包是什么
* 闭包是由函数及其相关引用环境组合而成的实体。
  * 闭包=函数+引用环境
* 匿名函数
  * 一般的函数都有函数名，而匿名函数没有。
  * 匿名函数不能独立存在，但可以直接调用或者赋值于某个变量。
  * 匿名函数也称为闭包，一个闭包继承了函数声明时的作用域。
  * 在Go语言中，所有的匿名函数都是闭包。
* 可以把闭包看成是一个类，一个闭包函数调用就是实例化一个类。
  * 闭包在运行时可以有多个实例，它会将同一个作用域里的变量和常量捕获下来，无论闭包在什么地方被调用（实例化时），都可以使用这些变量和常量。
  * 实例之间互不影响
  * 闭包捕获的变量和常量是引用传递，不是值传递

## 2.6 延迟语句如何配合恢复语句
* 函数总是会返回一个error，留给调用者处理
* panic会停掉当前正在执行的程序，而不只是当前线程。
  * 在这之前，它会有序地执行完当前线程defer列表里的语句，其他协程里定义的defer语句不做保证。  
    * 所以在defer里定义一个recover语句，防止程序直接挂掉，就可以起到类似Java里try...catch的效果
    * recover()函数只在defer的函数中直接调用才有效
      ```go
      defer recover()   //不行，要在defer函数里调用recover
      defer func(){
        defer func(){
          recover()
        }()
      }()               //不行，多重defer嵌套
      ```

## 2.7 defer链如何被遍历执行（<font color="red"> 着实没看懂</font>）
* 被defered的函数，以“先进后出”的顺序，在RET指令前得以执行。
* 在一条函数调用链中，多个函数中会出现多个defer语句。  
  例如：a()→b()→c()中，每个函数里都有defer语句，
  * 这些defer语句会创建对应个数的_defer结构体，多个_defer结构体形成一个链表，G结构体中某个字段指向此链表。
  * defer语句会先调用deferporc函数，new一个_defer结构体，挂到G上。
  * 调用new之前会优先从当前G所绑定的P的defer pool里取，没取到则会去全局的defer pool里取，实在没有的话才新建一个。（这是Go runtime里非常常见的操作，即设置多级缓冲，提升运行效率）
* 在执行RET指令之前，调用deferreturn函数完成_defer链表的遍历，执行完这条链上所有被defered的函数。
  * 在deferreturn函数的最后，会使用jmpdefer跳转到之前被defered的函数，这时控制权从runtime转移到了用户自定义的函数
* 在构造_defer结构体的时候，需要将当前函数的SP(栈顶指针)、被defered的函数指针保存到_defer结构体中。
  * 并且会将被defered的函数所需要的参数复制到和_defer结构体相邻的位置
  * 在调用被defered的函数的时候，用的就是这时被复制的值，相当于使用了它的一个“快照”，如果此参数不是指针或引用类型的话，会产生一些意料之外的bug
* 每执行完一个被defered的函数后，都会将_defer结构体从链表中删除并回收

## 2.8 为什么无法从父goroutine恢复子goroutine的panic
* 一般的说，也就是为什么无法recover其他goroutine里产生的panic？  
  * 可以简单地认为是设计使然：因为goroutine被设计为一个独立的代码执行单元，拥有自己的执行栈，不与其他goroutine共享任何数据。这意味着，无法让goroutine拥有返回值、也无法让goroutine拥有自身的ID编号等。
  * 若需要与其他的goroutine产生交互，要么可以使用channel的方式与其他goroutine进行通信，要么通过共享内存同步方式对共享的内存添加读写锁
  * 不完美的办法：  
    如果希望有一个全局的恐慌捕获中心，可以创建一个恐慌通知channel，并在产生恐慌时，通过recover字段将其恢复，并将发生的错误通过channel通知给这个全局的恐慌通知器
  * 根本途径
    提高程序员自身对语言的认识，多进行代码测试，以及多通过运维技术来增强容灾机制。
* 为什么希望从父goroutine中恢复子goroutine内产生的panic？  
  如果以下的情况发生在应用程序内，那么整个进程必然退出：
  ```go
  go func() {panic("die die die")}() 
  //上面的代码是显式的panic，实际情况下，如果不注意编码规范，极有可能触发一些本可以避免的恐慌错误，例如访问越界
  ```