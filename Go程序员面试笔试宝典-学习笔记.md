# 第1章 逃逸分析
* 在C/C++中，
  * 可以通过调用malloc函数或使用new运算符从堆上分配到一块内存；
  * 该内存的使用、销毁的责任都在程序员；
  * 一不小心，就会发生内存泄漏（比如，程序员忘记销毁）。
* 在Go语言中，
  * 程序员基本上不需要担心内存泄露了；
  * Go也有内建函数new，但调用new函数得到的内存不一定在堆上，还可能在栈上；
  * 一个变量是在堆上分配，还是在栈上分配，是经编译器的逃逸分析之后得出的“结论”。
## 1.1 逃逸分析是什么
* 堆与栈
  * 栈内存分配非常快。栈分配内存只需要通过PUSH指令，并且会被自动释放。局部变量是在栈上分配的（即静态内存分配），函数一旦执行完毕，变量占据的内存空间会被销毁；
  * 堆适合不可预知大小的内存分配。代价是分配速度较慢，而且会形成内存碎片。堆分配内存首先需要去找到一个合适大小的内存块，之后要通过垃圾回收才能释放。堆上创建的变量（动态内存分配），在函数退出时不会被销毁。

* 编译器的逃逸分析：  
  它是编译器执行静态代码分析后，对内存管理进行的优化和简化。
* 逃逸分析：
  * 在编译原理中，分析指针动态范围的方法被称之为逃逸分析。
  * 通俗来讲，当一个对象的指针被多个方法或线程引用时，则称这个指针发生了逃逸。
  * 逃逸分析决定一个变量是分配在堆上还是分配在栈上。

## 1.2 逃逸分析有什么用
* C/C++中动态分配的内存需要手动释放
  * 好处：程序员可以完全掌控内存
  * 缺点：例如经常忘记释放内存，导致内存泄漏。为此，很多现代语言都包含了垃圾回收机制
* Go的垃圾回收  
  让堆和栈对程序员保持透明。让程序员可以专注于业务，把内存管理的复杂机制交给编译器。

* 逃逸分析把变量合理地分配到它该去的地方
  * 即使是用new函数申请到的内存，如果编译器发现这块内存在退出函数后就没有使用了，那就分配到栈上（栈上的内存分配比堆上快很多）
  * 即使表面上只是一个普通的变量，但是经编译器的逃逸分析后发现，在函数之外还有其他的地方在引用，那就分配到堆上
  * 通过逃逸分析，可以尽量把那些不需要分配到堆上的变量直接分配到栈上：  
    堆上的变量少了，会减轻堆内存分配的开销，同时也会减少垃圾回收（Garbage Collection，GC）的压力，提高程序的运行速度。
* 如果变量都分配到堆上   
  堆不像栈可以自动清理。就会引起Go频繁地进行垃圾回收，而垃圾回收会占用比较大的系统开销

## 1.3 逃逸分析是怎么完成的
* Go语言逃逸分析最基本的原则：  
  如果一个函数返回对一个变量的引用，那么这个变量就会发生逃逸。
* 编译器会分析代码的特征和代码的生命周期
  * Go中的变量只有在编译器可以证明在函数返回后不会再被引用的，才分配到栈上，其他情况下都是分配到堆上。
  * Go语言中没有一个关键字或者函数可以直接让变量被分配到堆上
  * 对一个变量取址，可能会被分配到堆上。
    * 编译器进行逃逸分析后，考虑到在函数返回后，此变量不会被引用，那么还是会被分配到栈上。

* 编译器会根据变量是否被外部引用来决定是否逃逸；
  * 如果变量在函数外部没有引用，则优先放到栈上。
    * 放到堆上的情形：定义了一个很大的数组，需要申请的内存过大，超出了栈的存储能力
  * 如果变量在函数外部存在引用，则优先放到堆上。

## 1.4 如何确定是否发生逃逸
* Go提供了相关的命令，可以查看变量是否发生逃逸
  ```go
  go build -gcflags '-m -l' main.go
  其中：
  -gcflags参数：用于启动编译器支持的额外标志。例如，
  -m用于输出编译器的优化细节（包括使用逃逸分析这种优化），
  -N可以关闭编译器优化，
  -l用于禁用函数的内联优化，防止逃逸被编译器通过内联彻底的抹除
  ```
* 有些函数的参数为interface类型，编译期间很难确定其参数的具体类型，也会发生逃逸
* 使用反汇编命令也可以看出变量是否发生逃逸。
  ```go
  go tool compile -S main.go
  输出中如果有newobject函数（用于在堆上分配一块内存），说明有东西被存放在堆上，也就是发生了逃逸。
  ```

## 1.5 Go与C/C++中的堆和栈是同一个概念吗
* C/C++中提及的“程序堆栈”本质上其实是操作系统层级的概念，通过C/C++语言的编译器和所在的系统环境来共同决定。
  * 在程序启动时，操作系统会自动维护一个所启动程序消耗内存的地址空间，并自动将这个空间从逻辑上划分为堆内存空间和栈内存空间。这时，
    * “栈”的概念是指程序运行时自动获得的一小块内存，而后续的函数调用所消耗的栈大小，会在编译期间由编译器决定，用于保存局部变量或者保存函数调用栈。
      * 如果在C/C++中声明一个局部变量，则会执行逻辑上的压栈操作，在栈中记录局部变量。
      * 当局部变量离开作用域之后，所谓的自动释放本质上是该位置的内存在下一次函数调用压栈的过程中，可以被无条件的覆盖
    * 对于堆而言，每当程序通过系统调用向操作系统申请内存时，会将所需的空间从维护的堆内存空间中分配出去，而在归还时则会将归还的内存合并到所维护的地址空间中。
* Go程序也是运行在操作系统上的程序，同样拥有前面提及的堆和栈的概念。区别在于，
  * 传统意义上的“栈”被Go语言的运行时全部消耗了，用于维护运行时各个组件之间的协调。例如，
    * 调度器、垃圾回收、系统调用等
  * 对于用户态的Go代码而言，它们所消耗的“堆和栈”，其实只是Go运行时通过管理向操作系统申请的堆内存，构造的逻辑上的“堆和栈”，它们的本质都是从操作系统申请而来的堆内存。
    * 由于用户态Go程序的“栈空间”是由运行时管理堆内存得来，相较于只有1MB的C/C++中的“栈”而言，Go程序拥有“几乎”无限的栈内存（1GB）。
  * 对于用户态Go代码消耗的栈，Go语言运行时会为了防止内存碎片化，会在适当的时候对整个栈进行深拷贝，将其整个复制到另一块内存区域（这个过程对用户态的代码是不可见的），这也是相较于传统意义上栈是一块固定分配好的内存所出现的另一处差异
    * 由于这个特点，指针的算术运算不再能奏效，因为在没有特殊说明的情况下，无法确定运算前后指针所指向的地址的内容是否已经被Go运行时移动。