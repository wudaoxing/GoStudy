# 第1章 逃逸分析
* 在C/C++中，
  * 可以通过调用malloc函数或使用new运算符从堆上分配到一块内存；
  * 该内存的使用、销毁的责任都在程序员；
  * 一不小心，就会发生内存泄漏（比如，程序员忘记销毁）。
* 在Go语言中，
  * 程序员基本上不需要担心内存泄露了；
  * Go也有内建函数new，但调用new函数得到的内存不一定在堆上，还可能在栈上；
  * 一个变量是在堆上分配，还是在栈上分配，是经编译器的逃逸分析之后得出的“结论”。
## 1.1 逃逸分析是什么
* 堆与栈
  * 栈内存分配非常快。栈分配内存只需要通过PUSH指令，并且会被自动释放。局部变量是在栈上分配的（即静态内存分配），函数一旦执行完毕，变量占据的内存空间会被销毁；
  * 堆适合不可预知大小的内存分配。代价是分配速度较慢，而且会形成内存碎片。堆分配内存首先需要去找到一个合适大小的内存块，之后要通过垃圾回收才能释放。堆上创建的变量（动态内存分配），在函数退出时不会被销毁。

* 编译器的逃逸分析：  
  它是编译器执行静态代码分析后，对内存管理进行的优化和简化。
* 逃逸分析：
  * 在编译原理中，分析指针动态范围的方法被称之为逃逸分析。
  * 通俗来讲，当一个对象的指针被多个方法或线程引用时，则称这个指针发生了逃逸。
  * 逃逸分析决定一个变量是分配在堆上还是分配在栈上。

## 1.2 逃逸分析有什么用
* C/C++中动态分配的内存需要手动释放
  * 好处：程序员可以完全掌控内存
  * 缺点：例如经常忘记释放内存，导致内存泄漏。为此，很多现代语言都包含了垃圾回收机制
* Go的垃圾回收  
  让堆和栈对程序员保持透明。让程序员可以专注于业务，把内存管理的复杂机制交给编译器。

* 逃逸分析把变量合理地分配到它该去的地方
  * 即使是用new函数申请到的内存，如果编译器发现这块内存在退出函数后就没有使用了，那就分配到栈上（栈上的内存分配比堆上快很多）
  * 即使表面上只是一个普通的变量，但是经编译器的逃逸分析后发现，在函数之外还有其他的地方在引用，那就分配到堆上
  * 通过逃逸分析，可以尽量把那些不需要分配到堆上的变量直接分配到栈上：  
    堆上的变量少了，会减轻堆内存分配的开销，同时也会减少垃圾回收（Garbage Collection，GC）的压力，提高程序的运行速度。
* 如果变量都分配到堆上   
  堆不像栈可以自动清理。就会引起Go频繁地进行垃圾回收，而垃圾回收会占用比较大的系统开销

## 1.3 逃逸分析是怎么完成的
* Go语言逃逸分析最基本的原则：  
  如果一个函数返回对一个变量的引用，那么这个变量就会发生逃逸。
* 编译器会分析代码的特征和代码的生命周期
  * Go中的变量只有在编译器可以证明在函数返回后不会再被引用的，才分配到栈上，其他情况下都是分配到堆上。
  * Go语言中没有一个关键字或者函数可以直接让变量被分配到堆上
  * 对一个变量取址，可能会被分配到堆上。
    * 编译器进行逃逸分析后，考虑到在函数返回后，此变量不会被引用，那么还是会被分配到栈上。

* 编译器会根据变量是否被外部引用来决定是否逃逸；
  * 如果变量在函数外部没有引用，则优先放到栈上。
    * 放到堆上的情形：定义了一个很大的数组，需要申请的内存过大，超出了栈的存储能力
  * 如果变量在函数外部存在引用，则优先放到堆上。